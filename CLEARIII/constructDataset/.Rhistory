settingA.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingA.width <- rbind(settingA.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingA.width <- rbind(settingA.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingA.width <- rbind(settingA.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
nsim <- 5000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/binary_noHarm_5050"
plotTitle <- "Setting B"
n <- 200
settingB.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingB.width <- rbind(settingB.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingB.width <- rbind(settingB.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingB.width <- rbind(settingB.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
nsim <- 5000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/binary_noRes_7550"
plotTitle <- "Setting C"
n <- 200
settingC.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingC.width <- rbind(settingC.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingC.width <- rbind(settingC.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingC.width <- rbind(settingC.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
nsim <- 1000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/MISTIE_RICV5"
plotTitle <- "Setting D"
n <- 200
settingD.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingD.width <- rbind(settingD.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingD.width <- rbind(settingD.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingD.width <- rbind(settingD.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
settingA.width <- data.frame(settingA.width)
settingB.width <- data.frame(settingB.width)
settingC.width <- data.frame(settingC.width)
settingD.width <- data.frame(settingD.width)
lab <- c("n", "our method", "m100", "m90",
"m75", "m50", "m25")
names(settingA.width) <- lab
names(settingB.width) <- lab
names(settingC.width) <- lab
names(settingD.width) <- lab
settingA <- xtable(settingA.width)
digits(settingA) <- c(0,0,rep(2,6))
print(settingA, include.rownames = FALSE)
settingA <- xtable(settingA.width)
digits(settingA) <- c(0,0,rep(2,9))
digits(settingA) <- c(0,0,rep(2,7))
print(settingA, include.rownames = FALSE)
library(xtable)
nsim <- 5000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/binary_noRes_5050"
plotTitle <- "Setting A"
n <- 200
settingA.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingA.width <- rbind(settingA.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingA.width <- rbind(settingA.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingA.width <- rbind(settingA.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
nsim <- 5000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/binary_noHarm_5050"
plotTitle <- "Setting B"
n <- 200
settingB.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingB.width <- rbind(settingB.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingB.width <- rbind(settingB.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingB.width <- rbind(settingB.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
nsim <- 5000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/binary_noRes_7550"
plotTitle <- "Setting C"
n <- 200
settingC.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingC.width <- rbind(settingC.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingC.width <- rbind(settingC.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingC.width <- rbind(settingC.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
nsim <- 1000
homWd <- "~/Dropbox/research/github/CI_for_propWhoBenefit/simulations/MISTIE_RICV5"
plotTitle <- "Setting D"
n <- 200
settingD.width <- c(n, avgWidth(n, nsim, homWd, plotTitle))
n <- 500
settingD.width <- rbind(settingD.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 1000
settingD.width <- rbind(settingD.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
n <- 2000
settingD.width <- rbind(settingD.width, c(n, avgWidth(n, nsim, homWd, plotTitle)))
settingA.width <- data.frame(settingA.width)
settingB.width <- data.frame(settingB.width)
settingC.width <- data.frame(settingC.width)
settingD.width <- data.frame(settingD.width)
lab <- c("n", "our method", "m100", "m90",
"m75", "m50", "m25", "H-M")
names(settingA.width) <- lab
names(settingB.width) <- lab
names(settingC.width) <- lab
names(settingD.width) <- lab
settingA <- xtable(settingA.width)
digits(settingA) <- c(0,0,rep(2,7))
print(settingA, include.rownames = FALSE)
settingB <- xtable(settingB.width)
digits(settingB) <- c(0,0,rep(2,7))
print(settingB, include.rownames = FALSE)
settingC <- xtable(settingC.width)
digits(settingC) <- c(0,0,rep(2,7))
print(settingC, include.rownames = FALSE)
settingD <- xtable(settingD.width)
digits(settingD) <- c(0,0,rep(2,7))
print(settingD, include.rownames = FALSE)
0.05/0.09
0.06/0.09
0.07/0.09
0.11/0.09
0.09/0.14
1-0.09/0.14
1-0.09/0.15
1-0.09/0.16
1-0.09/0.20
1-0.09/0.28
settingB.width
1-settingB.width[,2]/settingB.width[,8]
1-0.09/0.12
1-0.05/0.07
1-0.036/0.053
1-0.025/0.0382
rm(list=ls())
setwd("~/Dropbox/research/github/CI_for_propWhoBenefit/CLEARIII/applyHorowitzManski")
maxBen <- 100
maxHarm <- 100
setwd("~/Dropbox/research/github/CI_for_propWhoBenefit_old/CLEARIII/constructDataset")
load("data.Rdata")
mort30data <- data.frame(trt = data$tmt, y = -data$mortality30)
library(lpSolveAPI)
library(boot)
#############################################################################
##Function for estimating bounds##
#############################################################################
boundsNoCov_res <- function(ordinalScale, YT, YC, maxBen, maxHarm){
nT <- length(YT) #number of treatment subjects
nC <- length(YC) #number of control subjects
if(nT == 0 | nC == 0){
#stop("WARNING: YT or YC is empty")
return(c(NA,NA,NA))
} else {
ordinalScale <- sort(ordinalScale, decreasing = FALSE)
L <- length(ordinalScale)
varCount <- L^2 #number of pi_{i,j}'s
#The matrix of pi_{i,j}'s is a L x L matrix with varCount pi_{i,j}'s.
scale <- nT * nC ##this can be made large to help with solving the linear program
#############################################################################
##Calculate marginal cdf's##
#############################################################################
cdf_C <- rep(0,L)
for (i in 1:L){
cdf_C[i] <- sum(YC <= ordinalScale[i])/nC
}
cdf_T <- rep(0,L)
for (i in 1:L){
cdf_T[i] <- sum(YT <= ordinalScale[i])/nT
}
#############################################################################
##Which pi_{i,j}'s are affected by the restrictions?##
#############################################################################
restrictions <- matrix(0,nrow=L,ncol=L)
for (i in 1:L){
for (j in 1:L){
if (ordinalScale[j]-ordinalScale[i]>maxBen | ordinalScale[i]-ordinalScale[j]>maxHarm){
restrictions[i,j] <- 1
}
}
}
restrictions <- c(restrictions)
#############################################################################
##LP for epsilon##
#############################################################################
lprec <- make.lp(0,(varCount+1))
##Setting objective function
objfn <- c(rep(0,varCount),1)
set.objfn(lprec,objfn)
##Setting non-negativity bounds
set.bounds(lprec, lower = rep(0, (varCount+1)), upper = NULL)
##pi_{i,j}'s sum to 1
add.constraint(lprec, xt = c(rep(1,varCount),0), "=", rhs = scale)
##incorporating the restrictions
add.constraint(lprec, xt = c(restrictions,0), "=", rhs = 0)
##marginal cdf constraints
pij.matrix <- matrix(1:varCount, nrow = L, ncol = L)
for (i in 1:(L-1)){
add.constraint(lprec, xt = c(rep(1,L*i),-1), "<=", rhs = (cdf_C[i]*scale), indices = c(pij.matrix[1:i,],(varCount+1)))
add.constraint(lprec, xt = rep(1,L*i+1), ">=", rhs = (cdf_C[i]*scale), indices = c(pij.matrix[1:i,],(varCount+1)))
}
for (i in 1:(L-1)){
add.constraint(lprec, xt = c(rep(1,L*i),-1), "<=", rhs = (cdf_T[i]*scale), indices = c(pij.matrix[,1:i],(varCount+1)))
add.constraint(lprec, xt = rep(1,L*i+1), ">=", rhs = (cdf_T[i]*scale), indices = c(pij.matrix[,1:i],(varCount+1)))
}
##Solving linear program
eps.flag <- solve(lprec)
if(eps.flag != 0){
stop("WARNING: problem with LP for eps")
}
eps <- get.objective(lprec)/scale
if (eps < 10 ^ (-10)){
eps <- 0
}
rm(lprec)
#############################################################################
##LP for lb and ub##
#############################################################################
lprec <- make.lp(0,varCount)
##Setting objective function
objfn <- matrix(0, L, L)
for (i in 1:L){
for (j in 1:L){
if (ordinalScale[j]>ordinalScale[i]){
objfn[i,j] <- 1
}
}
}
objfn <- c(objfn)
set.objfn(lprec,objfn)
##Setting non-negativity bounds
set.bounds(lprec, lower = rep(0, varCount), upper = NULL)
##pi_{i,j}'s sum to 1
add.constraint(lprec, xt = rep(1,varCount), "=", rhs = scale)
##incorporating the restrictions
add.constraint(lprec, xt = restrictions, "=", rhs = 0)
##marginal cdf constraints
for (i in 1:(L-1)){
add.constraint(lprec, xt = rep(1,L*i), "<=", rhs = (cdf_C[i]+eps)*scale, indices = c(pij.matrix[1:i,]))
add.constraint(lprec, xt = rep(1,L*i), ">=", rhs = (cdf_C[i]-eps)*scale, indices = c(pij.matrix[1:i,]))
}
for (i in 1:(L-1)){
add.constraint(lprec, xt = rep(1,L*i), "<=", rhs = (cdf_T[i]+eps)*scale, indices = c(pij.matrix[,1:i]))
add.constraint(lprec, xt = rep(1,L*i), ">=", rhs = (cdf_T[i]-eps)*scale, indices = c(pij.matrix[,1:i]))
}
lb.flag <- solve(lprec)
if(lb.flag != 0){
stop("WARNING: problem with LP for lb")
}
lb <- get.objective(lprec)/scale
lp.control(lprec,sense='max')
ub.flag <- solve(lprec)
if(ub.flag != 0){
stop("WARNING: problem with LP for ub")
}
ub <- get.objective(lprec)/scale
return(c(lb,ub,eps))
}
}
#############################################################################
##Inputs##
#############################################################################
getCI.mOfn <- function(maxBen, maxHarm, outcomeLevels, datasamp){
N <- nrow(datasamp)
propN <- c(1,0.9,0.75,0.5,0.25)
numM <- length(propN)
B <- 10000
CI <- rep(NA,2*numM)
#datasamp <- data.frame(trt = sample(0:1, size = N, replace = TRUE))
#datasamp$y = NA
#NT <- sum(datasamp$trt==1)
#NC <- N - NT
#datasamp$y[datasamp$trt==1] <- sample(1:2, size = NT, replace = TRUE, prob = c(0.5, 0.5))
#datasamp$y[datasamp$trt==0] <- sample(1:2, size = NC, replace = TRUE, prob = c(0.5, 0.5))
#############################################################################
##Get CI's with m-out-of-n bootstrap##
#############################################################################
for (iter in 1:numM){
print(ceiling(propN[iter]*N))
bounds <- matrix(NA, nrow = B, ncol = 3)
for (b in 1:B){
dataresamp <- datasamp[sample(1:N,ceiling(N*propN[iter]), replace = TRUE),]
YT <- dataresamp$y[dataresamp$trt == 1]
YC <- dataresamp$y[dataresamp$trt == 0]
bounds[b,] <- boundsNoCov_res(outcomeLevels, YT, YC, maxBen, maxHarm)
}
leftLimit <- quantile(bounds[,1], probs = 0.025)
rightLimit <- quantile(bounds[,2], probs = 0.975)
CI[c(iter*2-1,iter*2)] <- c(leftLimit, rightLimit)
}
return(CI)
}
mort30data <- data.frame(trt = data$tmt, y = -data$mortality30)
mort30.ci <- getCI.mOfn(maxBen, maxHarm, c(-1,0), mort30data)
mort30.ci
round(mrs30.ci, digits = 2)
round(mort30.ci, digits = 2)
rm(list=ls())
rm(list=ls())
setwd("~/Dropbox/research/github/CI_for_propWhoBenefit/CLEARIII/applyHorowitzManski")
boundsNoCov_res <- function(ordinalScale, YT, YC, maxBen, maxHarm){
nT <- length(YT) #number of treatment subjects
nC <- length(YC) #number of control subjects
if(nT == 0 | nC == 0){
#stop("WARNING: YT or YC is empty")
return(c(NA,NA,NA))
} else {
ordinalScale <- sort(ordinalScale, decreasing = FALSE)
L <- length(ordinalScale)
varCount <- L^2 #number of pi_{i,j}'s
#The matrix of pi_{i,j}'s is a L x L matrix with varCount pi_{i,j}'s.
scale <- nT * nC ##this can be made large to help with solving the linear program
#############################################################################
##Calculate marginal cdf's##
#############################################################################
cdf_C <- rep(0,L)
for (i in 1:L){
cdf_C[i] <- sum(YC <= ordinalScale[i])/nC
}
cdf_T <- rep(0,L)
for (i in 1:L){
cdf_T[i] <- sum(YT <= ordinalScale[i])/nT
}
#############################################################################
##Which pi_{i,j}'s are affected by the restrictions?##
#############################################################################
restrictions <- matrix(0,nrow=L,ncol=L)
for (i in 1:L){
for (j in 1:L){
if (ordinalScale[j]-ordinalScale[i]>maxBen | ordinalScale[i]-ordinalScale[j]>maxHarm){
restrictions[i,j] <- 1
}
}
}
restrictions <- c(restrictions)
#############################################################################
##LP for epsilon##
#############################################################################
lprec <- make.lp(0,(varCount+1))
##Setting objective function
objfn <- c(rep(0,varCount),1)
set.objfn(lprec,objfn)
##Setting non-negativity bounds
set.bounds(lprec, lower = rep(0, (varCount+1)), upper = NULL)
##pi_{i,j}'s sum to 1
add.constraint(lprec, xt = c(rep(1,varCount),0), "=", rhs = scale)
##incorporating the restrictions
add.constraint(lprec, xt = c(restrictions,0), "=", rhs = 0)
##marginal cdf constraints
pij.matrix <- matrix(1:varCount, nrow = L, ncol = L)
for (i in 1:(L-1)){
add.constraint(lprec, xt = c(rep(1,L*i),-1), "<=", rhs = (cdf_C[i]*scale), indices = c(pij.matrix[1:i,],(varCount+1)))
add.constraint(lprec, xt = rep(1,L*i+1), ">=", rhs = (cdf_C[i]*scale), indices = c(pij.matrix[1:i,],(varCount+1)))
}
for (i in 1:(L-1)){
add.constraint(lprec, xt = c(rep(1,L*i),-1), "<=", rhs = (cdf_T[i]*scale), indices = c(pij.matrix[,1:i],(varCount+1)))
add.constraint(lprec, xt = rep(1,L*i+1), ">=", rhs = (cdf_T[i]*scale), indices = c(pij.matrix[,1:i],(varCount+1)))
}
##Solving linear program
eps.flag <- solve(lprec)
if(eps.flag != 0){
stop("WARNING: problem with LP for eps")
}
eps <- get.objective(lprec)/scale
if (eps < 10 ^ (-10)){
eps <- 0
}
rm(lprec)
#############################################################################
##LP for lb and ub##
#############################################################################
lprec <- make.lp(0,varCount)
##Setting objective function
objfn <- matrix(0, L, L)
for (i in 1:L){
for (j in 1:L){
if (ordinalScale[j]>ordinalScale[i]){
objfn[i,j] <- 1
}
}
}
objfn <- c(objfn)
set.objfn(lprec,objfn)
##Setting non-negativity bounds
set.bounds(lprec, lower = rep(0, varCount), upper = NULL)
##pi_{i,j}'s sum to 1
add.constraint(lprec, xt = rep(1,varCount), "=", rhs = scale)
##incorporating the restrictions
add.constraint(lprec, xt = restrictions, "=", rhs = 0)
##marginal cdf constraints
for (i in 1:(L-1)){
add.constraint(lprec, xt = rep(1,L*i), "<=", rhs = (cdf_C[i]+eps)*scale, indices = c(pij.matrix[1:i,]))
add.constraint(lprec, xt = rep(1,L*i), ">=", rhs = (cdf_C[i]-eps)*scale, indices = c(pij.matrix[1:i,]))
}
for (i in 1:(L-1)){
add.constraint(lprec, xt = rep(1,L*i), "<=", rhs = (cdf_T[i]+eps)*scale, indices = c(pij.matrix[,1:i]))
add.constraint(lprec, xt = rep(1,L*i), ">=", rhs = (cdf_T[i]-eps)*scale, indices = c(pij.matrix[,1:i]))
}
lb.flag <- solve(lprec)
if(lb.flag != 0){
stop("WARNING: problem with LP for lb")
}
lb <- get.objective(lprec)/scale
lp.control(lprec,sense='max')
ub.flag <- solve(lprec)
if(ub.flag != 0){
stop("WARNING: problem with LP for ub")
}
ub <- get.objective(lprec)/scale
return(c(lb,ub,eps))
}
}
setwd("~/Dropbox/research/github/CI_for_propWhoBenefit_OLD/CLEARIII/constructDataset")
load("data.Rdata")
maxBen <- 100
maxHarm <- 100
B <- 10000
mort30data <- data.frame(trt = data$tmt, y = -data$mortality30)
mort30data
head(mort30data)
nrow(mort30data)
library(lpSolveAPI)
datasamp <- mort30data
outcomeLevels <- c(-1,0)
bounds_trial <- boundsNoCov_res(outcomeLevels, datasamp$y[datasamp$trt==1], datasamp$y[datasamp$trt==0], maxBen, maxHarm)
lb_trial <- bounds_trial[1]
ub_trial <- bounds_trial[2]
lb_trial
ub_trial
B
N <- nrow(datasamp)
bounds <- matrix(NA, nrow = B, ncol = 3)
dataresamp <- datasamp[sample(1:N,N, replace = TRUE),]
YT <- dataresamp$y[dataresamp$trt == 1]
YC <- dataresamp$y[dataresamp$trt == 0]
boundsNoCov_res(outcomeLevels, YT, YC, maxBen, maxHarm)
bounds <- matrix(NA, nrow = B, ncol = 3)
for (b in 1:B){
dataresamp <- datasamp[sample(1:N,N, replace = TRUE),]
YT <- dataresamp$y[dataresamp$trt == 1]
YC <- dataresamp$y[dataresamp$trt == 0]
bounds[b,] <- boundsNoCov_res(outcomeLevels, YT, YC, maxBen, maxHarm)
}
lb_star <- bounds[,1]
ub_star <- bounds[,2]
z_candidates <- seq(from = 0, to = 1, by = 0.001) ##candidates for z_na
prob_z <- sapply(X = z_candidates, FUN = function(z){mean(lb_star - z <= lb_trial & ub_trial <= ub_star + z)})
z_na <- min(z_candidates[which(prob_z >= 0.95)])
leftLimit <- lb_trial - z_na
rightLimit <- ub_trial + z_na
if (leftLimit < 0){ ##We know the lower bound is 0 at minimum
leftLimit <- 0
}
if (rightLimit > 1){ ##We know the upper bound is 1 at maximum
rightLimit <- 1
}
CI <- c(leftLimit, rightLimit)
CI
getCI.HM <- function(maxBen, maxHarm, outcomeLevels, datasamp, B){
##Bound estimates for trial data
bounds_trial <- boundsNoCov_res(outcomeLevels, datasamp$y[datasamp$trt==1], datasamp$y[datasamp$trt==0], maxBen, maxHarm)
lb_trial <- bounds_trial[1]
ub_trial <- bounds_trial[2]
##Sample size
N <- nrow(datasamp)
##Bound estimates for bootstrap replicate data sets
bounds <- matrix(NA, nrow = B, ncol = 3)
for (b in 1:B){
dataresamp <- datasamp[sample(1:N,N, replace = TRUE),]
YT <- dataresamp$y[dataresamp$trt == 1]
YC <- dataresamp$y[dataresamp$trt == 0]
bounds[b,] <- boundsNoCov_res(outcomeLevels, YT, YC, maxBen, maxHarm)
}
lb_star <- bounds[,1]
ub_star <- bounds[,2]
##Find z_na
z_candidates <- seq(from = 0, to = 1, by = 0.001) ##candidates for z_na
prob_z <- sapply(X = z_candidates, FUN = function(z){mean(lb_star - z <= lb_trial & ub_trial <= ub_star + z)})
z_na <- min(z_candidates[which(prob_z >= 0.95)])
##Get CI
leftLimit <- lb_trial - z_na
rightLimit <- ub_trial + z_na
if (leftLimit < 0){ ##We know the lower bound is 0 at minimum
leftLimit <- 0
}
if (rightLimit > 1){ ##We know the upper bound is 1 at maximum
rightLimit <- 1
}
CI <- c(leftLimit, rightLimit)
return(CI)
}
setwd("~/Dropbox/research/github/CI_for_propWhoBenefit/CLEARIII/constructDataset")
mort30data <- data.frame(trt = data$tmt, y = -data$mortality30)
mort30.ci <- getCI.HM(maxBen, maxHarm, c(-1,0), mort30data, B)
mort180data <- data.frame(trt = data$tmt, y = -data$mortality180)
mort180data <- subset(mort180data, !is.na(y))
mort180.ci <- getCI.HM(maxBen, maxHarm, c(-1,0), mort180data, B)
mrs30data <- data.frame(trt = data$tmt, y = -data$rankin30)
mrs30data <- subset(mrs30data, !is.na(y))
mrs30.ci <- getCI.HM(maxBen, maxHarm, (-6):0, mrs30data, B)
mrs180data <- data.frame(trt = data$tmt, y = -data$rankin180)
mrs180data <- subset(mrs180data, !is.na(y))
mrs180.ci <- getCI.HM(maxBen, maxHarm, (-6):0, mrs180data, B)
round(mrs30.ci, digits = 2)
round(mrs180.ci, digits = 2)
round(mort30.ci, digits = 2)
round(mort180.ci, digits = 2)
